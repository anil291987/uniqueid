// Copyright The swift-UniqueID Contributors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import XCTest

@testable import UniqueID

final class UUIDv6Tests: XCTestCase {}


// ------------------------------------------
// MARK: - Creation API.
// ------------------------------------------


extension UUIDv6Tests {

  func testCreateWithComponents() {

    do {
      let uuid = UniqueID.timeOrdered(rawTimestamp: 0, sequence: 0, node: 0)
      XCTAssertEqual(uuid.serialized(), "00000000-0000-6000-8000-000000000000")
      XCTAssertEqual(uuid.version, 6)
      XCTAssertEqual(uuid.components(.timeOrdered)?.rawTimestamp, 0 as UInt64)
      XCTAssertEqual(uuid.components(.timeOrdered)?.sequence, 0 as UInt16)
      XCTAssertEqual(uuid.components(.timeOrdered)?.node, 0 as UInt64)
    }
    do {
      let uuid = UniqueID.timeOrdered(
        rawTimestamp: 0xABCD_B0B0_FEED_FACE, sequence: 0xF9F9, node: 0xABCD_B0B0_FEED_FACE
      )
      XCTAssertEqual(uuid.serialized(), "BCDB0B0F-EEDF-6ACE-B9F9-B0B0FEEDFACE")
      XCTAssertEqual(uuid.version, 6)
      // Bottom 60 bits of timestamp preserved.
      XCTAssertEqual(uuid.components(.timeOrdered)?.rawTimestamp, 0xBCD_B0B0_FEED_FACE as UInt64)
      // Bottom 14 bits of sequence preserved.
      XCTAssertEqual(uuid.components(.timeOrdered)?.sequence, 0x39F9 as UInt16)
      // Bottom 48 bits of node preserved.
      XCTAssertEqual(uuid.components(.timeOrdered)?.node, 0x0000_B0B0_FEED_FACE as UInt64)
    }
  }

  func testRandomNodeHasMulticastBit() {

    // [RFC-4122] 4.5. Node IDs that Do Not Identify the Host
    //
    // A better solution is to obtain a 47-bit cryptographic quality random
    // number and use it as the low 47 bits of the node ID, with the least
    // significant bit of the first octet of the node ID set to one.  This
    // bit is the unicast/multicast bit, which will never be set in IEEE 802
    // addresses obtained from network cards.  Hence, there can never be a
    // conflict between UUIDs generated by machines with and without network
    // cards.
    for _ in 0..<10_000 {
      let randomNode = UniqueID.timeOrdered().components(.timeOrdered)!.node
      XCTAssertTrue((randomNode &>> 40) & 1 == 1)
    }
  }
}


// ------------------------------------------
// MARK: - Creation functionality.
// ------------------------------------------


extension UUIDv6Tests {

  func testTimestamp() {

    let beforeCreate = Date()
    let beforeCreateRaw = UInt64(beforeCreate.timeIntervalSince1970 * 10_000_000) + 0x01B2_1DD2_1381_4000
    Thread.sleep(forTimeInterval: 1 /* second */)

    let uniqueIDs = (0..<10).map { _ in UniqueID.timeOrdered() }
    Thread.sleep(forTimeInterval: 1 /* second */)

    let afterCreate = Date()
    let afterCreateRaw = UInt64(afterCreate.timeIntervalSince1970 * 10_000_000) + 0x01B2_1DD2_1381_4000

    for uuid in uniqueIDs {
      guard let components = uuid.components(.timeOrdered) else {
        XCTFail("Not a valid UUIDv6")
        continue
      }
      #if !NO_FOUNDATION_COMPAT
        XCTAssertGreaterThan(components.timestamp, beforeCreate)
        XCTAssertLessThan(components.timestamp, afterCreate)
      #endif  // NO_FOUNDATION_COMPAT
      XCTAssertGreaterThan(components.rawTimestamp, beforeCreateRaw)
      XCTAssertLessThan(components.rawTimestamp, afterCreateRaw)
    }
  }

  func testParallelClockSequenceGeneration() {

    // Run a number of (hopefully) parallel tasks, each generating a lot of v6 UUIDs with a stable node ID.
    let numberOfTasks = 32
    let uuidsPerTask = 33_000

    let results = Array<[UniqueID]>(unsafeUninitializedCapacity: numberOfTasks) { buffer, count in
      let buffer = buffer
      let group = DispatchGroup()
      group.enter()
      DispatchQueue.global(qos: .userInitiated).async {
        DispatchQueue.concurrentPerform(iterations: numberOfTasks) { taskOffset in
          (buffer.baseAddress! + taskOffset).initialize(
            to: (0..<uuidsPerTask).map { _ in UniqueID.timeOrdered(node: 0xABCD_B0B0_FEED_FACE) }
          )
        }
        group.leave()
      }
      group.wait()
      count = numberOfTasks
    }

    // Check that each list contains the expected number of UUIDs, and they are all valid.
    for taskResults in results {
      XCTAssertEqual(taskResults.count, uuidsPerTask)
      XCTAssert(taskResults.allSatisfy { $0.components(.timeOrdered)?.node == 0x0000_B0B0_FEED_FACE as UInt64 })
    }

    // Check that there are no duplicates.
    var allUniqueIDs = Set<UniqueID>()
    allUniqueIDs.reserveCapacity(numberOfTasks * uuidsPerTask)
    for uuid in results.joined() {
      XCTAssert(allUniqueIDs.insert(uuid).inserted, "Duplicate! \(uuid)")
    }
    XCTAssertEqual(allUniqueIDs.count, numberOfTasks * uuidsPerTask)

    // We would expect to see IDs with different sequence numbers,
    // indicating colliding timestamps.
    if let sampleSequence = allUniqueIDs.first?.components(.timeOrdered)?.sequence {
      let sequenceDidChange = allUniqueIDs.contains {
        ($0.components(.timeOrdered)?.sequence ?? sampleSequence) != sampleSequence
      }
      if !sequenceDidChange {
        print(
          """
          ⚠️ Warning ⚠️ - all UUIDs had the same sequence number.
          This could indicate that tasks did not run in parallel.
          """
        )
      }
    }
  }
}
